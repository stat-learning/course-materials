<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>decomposing-mse.utf8</title>
    <meta charset="utf-8" />
    <link href="libs/remark-css-0.0.1/fc.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/fc-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="reed.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">







&lt;img src="figs/many-draws.gif" width="620" style="display: block; margin: auto;" /&gt;

---

# Generating from Generative Models

Many statistical models are **generative**: they represent probability distributions
from which we're able to take random samples. That is, once you have the model
(true or estimated) you are able to generate as much data as you like.


---
# Simulation from true model (ex: polynomial regression)

True mean function:
$$
`\begin{array}
\textrm{f}(x) &amp;= \beta_0 + \beta_1 x + \beta_2 x^2 \\
&amp;= 23 + 4 x - 3.2 x^2
\end{array}`
$$

--

True data generating function:

$$
y = f(x) + \epsilon; \quad \epsilon \sim N(0, 11) \\
$$

$$
Y|X \sim N(\mu = f(x), \, \sigma = 11)
$$

--


```r
n &lt;- 20
x &lt;- runif(n, min = 5, max = 35)
f &lt;- function(x) {
  23 + 11 * x - .4 * x^2
}
y &lt;- rnorm(length(x), mean = f(x), sd = 11)
```


---

$$
f(x) = \beta_0 + \beta_1 x + \beta_2 x^2
$$

&lt;img src="decomposing-mse_files/figure-html/unnamed-chunk-4-1.png" width="576" style="display: block; margin: auto;" /&gt;


---

$$
y = \beta_0 + \beta_1 x + \beta_2 x^2 + \epsilon; \, n = 20
$$

&lt;img src="decomposing-mse_files/figure-html/unnamed-chunk-5-1.png" width="576" style="display: block; margin: auto;" /&gt;


---

$$
y = \beta_0 + \beta_1 x + \beta_2 x^2 + \epsilon; \, n = 20000
$$

&lt;img src="decomposing-mse_files/figure-html/unnamed-chunk-6-1.png" width="576" style="display: block; margin: auto;" /&gt;


---

# Visualizing Bias and Variance

## Procedure

1. Assume true generative model

--

2. Generate data set of size `\(n\)`

--

3. Estimate `\(\hat{f}\)`

--

4. Repeat 2 and 3 many times to get a sense of the variation in `\(\hat{f}\)`


## Estimating `\(\hat{f}\)`

Let's naively assume a *linear form*, work with data sets of size 20, and fit 
`\(\hat{f}\)` by least squares.

$$
f(x) = \beta_0 + \beta_1 x
$$

---



&lt;img src="figs/many-draws-2.gif" width="620" style="display: block; margin: auto;" /&gt;


---



## Estimating `\(\hat{f}\)`, take two

Next, let's presciently assume a quadratic form...

---

&lt;img src="figs/many-draws-3.gif" width="620" style="display: block; margin: auto;" /&gt;

---
## Estimating `\(\hat{f}\)`, take three (or seven?)

Finally, let's get ridiculous and assume a septic form...

---



&lt;img src="figs/many-draws-4.gif" width="620" style="display: block; margin: auto;" /&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "atelier-forest-light",
"highlightLines": true,
"highlightSpans": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
